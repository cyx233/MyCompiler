# 实验报告
#### 计81 陈雨翔 2018011295
## 任务概述
1. 改进语法
2. 修改名称解析器，对数组的size进行正确计算
3. 修改类型检查，现在指针类型可以与整数相加减
4. 修改Locator，使其支持对数组索引的计算
5. 修改irGen，对指针与整数的相加减进行特判
## 遇到的困难
很多细节没有考虑到，通过Failed的测例不断修改
1. 发现全局变量找不到了，花了很久定位问题，最后发现是修改Namer时候误重写了函数visitGlobalDecl，导致没有visitChildren()了
2. 指针与整数的加法，例如(int*)p + 1，这里的1应该是“指针向后移动一整个位置”，即地址增加指针所指类型的size，但是一开始编写成了“地址+1”。定位问题比较麻烦，解决办法比较简单，在+，-，*，/时特别判断两边的类型就行了。
3. failcase出了很多问题，主要是没有考虑到的问题。只要修改类型检查某些类就行了。
4. 诸如忘记修改“已有变量数量”（因为数组应该算多个）之类的问题。主要是因为码量多了，但没有写什么单元测试，全靠测例+print进行debug，感觉已经有些捉襟见肘。
## 思考题
### 第一题
A: \*(int\*)(4096 + 23 * 4)

B: \*(int\*)(4096 + 23 * 4)

C: \*(int\*)(4096 + 2 * 40 + 3 * 4)

D: \*(int\)(\*(int\*\*)(4096 + 2 * 4) + 3 * 4)

E: \*(int\)(\*(int\*\*)(4096 + 2 * 4) + 3 * 4)

### 第二题
也就是说必须在运行期间决定栈帧的位置。

不妨先假设所有的可变长数组size均为0，然后增加一个用户不可见的全局变量delta，delta用于记录编译时确定的变量offset与实际运行时分配的位置的距离。

如果声明可变长数组size=n，先将fp-delta以下位置（fp～fp-delta是已经声明的变长数组的空间）的所有变量复制到地址减小4\*n的位置，然后fp-delta记录为变长数组的头指针位置（更改名称解析中的数值），然后delta=delta-4\*n。所有时候分配变量地址都是fp-offset-delta。当离开作用域时，delta=0，所有的变量复制到地址增大delta的位置，再进行正常的Pop操作（变长数组认为size=0,不需要pop）。这样就可以实现在运行时动态分配栈帧的目的。

考虑到需要copy变量，其实需要两个全局变量，一个是old\_delta,一个是delta。在对应复制步骤的操作就是两个位置按规则复制。