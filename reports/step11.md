# 实验报告
#### 计81 陈雨翔 2018011295
## 任务概述
1. 改进语法
2. 实现类型解析器
4. 类型解析器实现左值检查
3. 类型解析器实现类型检查
4. 实现指针以及取地址运算（&），间接访问（*）
## 遇到的困难
如同实验指导所说，是代码量非常大的一次任务。而且实验指导没有说很多细节，主要是看示例代码完成这一步。

类型解析器也是Visitor设计模式，但是逻辑比Namer和irGen简单一些。只需要在叶节点返回对应的类型信息，在运算、调用节点按照类型运算规则返回即可。遍历cst后能让每个需要类型的节点都对应一个类型，保存在字典typeInfo中。示例代码写了保存类型标签的装饰器，非常简洁。

刚开始觉得左值解析有些复杂，无从下手。不过实验指导中点出了，左值其实可以理解为“有地址的值”，一下子就变得简单了，只需要判断某个表达式否有分配地址即可。至于是否分配地址，在nameInfo中就有记录，最基础的左值是局部变量与全局变量，根据实验指导说的规则可以判断复杂表达式是否为左值。Locator是根据规则计算表达式地址的类。

类型检查方面参考了示例代码。示例代码使用了函数对象以及装饰器等技术，代码简洁，结构清晰。每个运算节点上，调用TypeRule装饰的不同函数进行类型检查，类型检查的返回值即为运算结果的类型。

完成类型解析器之后，还是有很多小问题，比如irGen关于左值的生成方法，并不能简单的visitChildren()，因为会visit加载（Load）变量的节点，产生错误（这里需要地址，不需要Load）。最终利用了Lacator类完成了对irGen的调整。

## 思考题
### 第一题
类型检查不仅需要检查编译器常量的类型是否正确，也要检查变量的类型是否正确。需要局部变量、全局变量、函数参数等信息才能进行类型检查。所以类型检查要放到名称解析之后。
### 第二题
比如python这样的弱类型语言。以及C++中auto类型。
### 第三题
需要注意检查是否是空指针。如果不是空指针的话，可以理解为无符号整数的比较，和原来实现的有符号整数比较不同。

## 代码复用
1. 示例代码的类型解析器
2. 示例代码中关于指针的类型定义